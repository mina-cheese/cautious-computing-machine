---
title: "code"
author: "mina-cheese"
format: html
editor: visual
---

```{r}
#library(pracma)
library(primes)
library(RcppAlgos)
```

# How the Algorithm Works

This algorithm comes from the paper Cluster Primes by Blecksmith, Erdos, and Selfridge.

Let $p_n$ be the $n$th prime which also happens to be a cluster prime. The algorithm inputs the index $n$ of the current cluster prime $p_n$ and returns the index of the next cluster prime.

Since $p_n$ is a cluster prime, any even integer from 2 to $p_n-3$ can be written as a difference of two primes not exceeding $p_n$. So in order to check that the next cluster prime $p_{n+1}$ is a cluster prime, we just need to check the even numbers in the interval $[p_n-1, p_{n+1}-3]$. If the prime gap $p_{n+1}-p_n=2,4, \text{ or } 6$, we are good. If $p_{n+1}-p_n=2$, the only even number between the two primes is $p_{n+1}-1$, which is not within the range we need to check. If $p_{n+1}-p_n=4$ or $6$, the only even numbers of concern are $p_{n+1}-3$ and $p_{n+1}-3, p_{n+1}-5$, respectively, which are already a difference of two acceptable primes by inspection.

If $p_{n+1}-p_n \geq 8$, $p_{n+1}$ is already a non-cluster prime since $p_{n+1}-9$ cannot be written as a difference of two smaller primes (proof?). Thus, we must continue the search to the next primes. Here, we examine the even numbers $p_{n+1}-t$ (even numbers which are not a difference of two primes), where $t$ is an odd composite less than or equal to $p_{n+1}-p_n+1$. Observe that these are the even numbers $p_{n+1}-t \geq p_n-1$ which is indeed our aforementioned lower bound of concern. We then look ahead in the sequence of primes $\{p_{n+1+m}\}_{m=1}^\infty$ one at a time until $q'=t+p_{n+1+m}-p_{n+1}$ is prime, as this means we can write $p_{n+1}-t=p_{n+1+m}-q'$ as a difference of two primes. This means that we are *at least* $m$ away from the next cluster prime, as $p_{n+1+m}$ is the first prime where $p_{n+1}-t$ can be written as a difference of two primes.

$M$ is the maximum number of primes to the next possible cluster prime, and changes as the algorithm progresses and $m$ increases. When we find a suitable $m$ where $p_{n+1}-t$ can be written as a difference of two primes $p_{n+1+m}-q'$, we must update $M$ to account for this "distance" to the next possible cluster prime, i.e. if $m>M$, we must update $M$ to be $m$ since $m$ is the minimum number of primes to where $p_{n+1}-t$ can be written as a difference of two primes (does this make any sense). Once we move to the next prime and begin the search again, we subtract one from $M$ as we have progressed to the next prime and are one closer to the next cluster prime. Note that as $m$ increases, so does the number of even numbers we need to search through, as we need to be able to write all even numbers up to $p_{n+1+m}-3$ as a difference of two primes. If the algorithm doesn't terminate, i.e. $M$ keeps getting larger, then that would imply there are finitely many cluster primes. However, this is a well-known hopeless problem, so for now we can assume for now that my computer is safe from blowing up.

# Implementing the Algorithm

At the minimum, the algorithm requires us to have a "small" list of odd composite numbers `odd_comp` and a list of prime differences `diff[n]`$=p_{n+1}-p_n$. The actual values of the primes themselves are not necessary for the algorithm to perform. However, since we now have advanced technology, we can just call a list of primes and make our lives easier (?). It def makes it easier to spot check at least!

```{r}
odd_comp <- c(9, 15, 21, 25, 27, 33, 35, 39, 45, 49, 51, 55, 57, 63, 65, 69, 75, 77, 81, 85, 87, 91, 93, 95, 99, 105, 111, 115, 117, 119, 121, 123, 125, 129, 133, 135, 141, 143, 145, 147, 153, 155, 159, 161, 165, 169, 171, 175, 177, 183, 185, 187, 189, 195, 201, 203, 205) # list of odd composites

#primes <- generate_primes(max=1e6) # list of primes

#diff <- diff(primes) # prime differences
```

Running into integer problems so i need to find another way to generate prime gaps.

```{r}
prime_differences_up_to <- function(limit, block_size = 1e7) {

  if (limit < 2) return(numeric(0))

  prev_prime <- NULL
  diffs <- numeric(0)

  for (start in seq(2, limit, by = block_size)) {
    end <- min(start + block_size - 1, limit)

    # generate all primes up to `end`
    p <- primeSieve(end)

    # keep only new primes in this block
    p <- p[p >= start]

    if (length(p) == 0) next

    # gap bridging blocks
    if (!is.null(prev_prime)) {
      diffs <- c(diffs, p[1] - prev_prime)
    }

    # within-block gaps
    if (length(p) > 1) {
      diffs <- c(diffs, diff(p))
    }

    prev_prime <- p[length(p)]
  }

  diffs
}
```

```{r}
diff <- prime_differences_up_to(1e6)
```

The algorithm as described above has been encoded into the following:

```{r}
find_next_cluster_prime <- function(n, primes, diff, odd_comp) {
  #current_prime <- primes[n]
  M <- 0

  repeat {
    d <- diff[n]

    if (d > 6) {
      for (t0 in odd_comp[odd_comp <= d + 1]) {
        m <- 1
        t <- t0

        repeat {
          m <- m + 1
          t <- t + diff[n + m - 1]

          if (isprime(t)==1) break
        }

        if (m > M) M <- m
      }
    }

    n <- n + 1
    #current_prime <- current_prime + d
    M <- M - 1

    if (M <= 0) break
  }

  return(n)
}

```

```{r}
next_n <- find_next_cluster_prime(n=7, primes, diff, odd_comp)
print(c(next_n, primes[next_n]))
```

note: 97 (25th prime) is the first non-cluster prime note: tested some small cluster prime values and they all worked. Should write a loop to compile a table

One must be careful when using this function, as it returns the next cluster prime given the index of a *cluster prime*, not just any prime.

We can now run a loop to get a list of cluster primes.

```{r}
find_next_cluster_prime(2, primes, diff, odd_comp)
```


```{r}
index = 1
for (j in 1:57) {
  next_cp <- find_next_cluster_prime(index, primes, diff, odd_comp)
  index <- next_cp
  
  print(c(next_cp, primes[next_cp]))
}
```

```{r}
out <- integer(0)

index <- 1
for (j in 1:57) {
  next_cp <- find_next_cluster_prime(index, primes, diff, odd_comp)
  index <- next_cp
  
  out <- c(out, primes[next_cp])
}

out
```


```{r}
cps <- c(3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 101, 103, 107, 109, 113, 131, 137, 139, 151, 157, 163, 167, 173, 179, 181, 193, 197, 199, 233, 239, 241, 271, 277, 281, 283, 311, 313, 317, 353, 359, 389, 401, 421, 433)



identical(cps, out)
```

We can also use this algorithm to tabulate the distribution of cluster primes. The following algorithm counts the number of cluster primes up to some number n.

```{r}
count_cluster_primes <- function(limit, primes, diff, odd_comp) {
  
  index <- 2  # 2 is not a cluster prime, so we start at 3
  count <- 1  # counting the first cluster prime

  repeat {
    next_index <- find_next_cluster_prime(index, primes, diff, odd_comp)

    if (primes[next_index] > limit) break

    index <- next_index
    count <- count + 1
  }

  return(count)
}

```

```{r}
count_cluster_primes(1000, primes, diff, odd_comp) # sanity check. there are indeed 99 cluster primes less than 1000
```

Comparing the number of cluster primes to the number of non-cluster primes up to some limit:

```{r}
limit <- 1e5
test_cp_count <- count_cluster_primes(limit, primes, diff, odd_comp) # number of cluster primes up to the limit
test_prime_count <- sum(primes <= limit) # number of primes up to the limit
test_non_cp_count <- prime_count - cp_count # number of non-cluster primes
test_twin_prime_count <- length(twin_primes(min=2, max=1e5))

c(cluster_primes = test_cp_count, non_cluster_primes = test_non_cp_count, twin_primes = test_twin_prime_count, primes = test_prime_count)
```

Testing to make sure it matches the results in the paper (it does).

# Results

```{r}
limits <- 10^(1:3)

results <- data.frame(
  limit = limits,
  cluster_primes = NA,
  non_cluster_primes = NA,
  twin_primes = NA,
  primes = NA
)

for (i in seq_along(limits)) {
  limit <- limits[i]

  cp_count <- count_cluster_primes(limit, primes, diff, odd_comp)
  prime_count <- sum(primes <= limit)
  non_cp_count <- prime_count - cp_count - 1 
  tp_count <- length(twin_primes(min=2, max=limit))

  results$cluster_primes[i] <- cp_count
  results$non_cluster_primes[i] <- non_cp_count
  results$twin_primes[i] <- tp_count
  results$primes[i] <- prime_count
}

results
```

make a table or something idk
