---
title: "code"
author: "mina-cheese"
format: html
editor: visual
---

```{r}
library(pracma)
```

# How the Algorithm Works

This algorithm comes from the paper Cluster Primes by Blecksmith, Erdos, and Selfridge.

Let $p_n$ be the $n$th prime which also happens to be a cluster prime. The algorithm inputs the index $n$ of the current cluster prime $p_n$ and returns the index of the next cluster prime.

Since $p_n$ is a cluster prime, any even integer from 2 to $p_n-3$ can be written as a difference of two primes not exceeding $p_n$. So in order to check that the next cluster prime $p_{n+1}$ is a cluster prime, we just need to check the even numbers in the interval $[p_n-1, p_{n+1}-3]$. If the prime gap $p_{n+1}-p_n=2,4, \text{ or } 6$, we are good. If $p_{n+1}-p_n=2$, the only even number between the two primes is $p_{n+1}-1$, which is not within the range we need to check. If $p_{n+1}-p_n=4$ or $6$, the only even numbers of concern are $p_{n+1}-3$ and $p_{n+1}-3, p_{n+1}-5$, respectively, which are already a difference of two acceptable primes by inspection.

If $p_{n+1}-p_n \geq 8$, $p_{n+1}$ is already a non-cluster prime since $p_{n+1}-9$ cannot be written as a difference of two smaller primes (proof?). Thus, we must continue the search to the next primes. Here, we examine the even numbers $p_{n+1}-t$ (even numbers which are not a difference of two primes), where $t$ is an odd composite less than or equal to $p_{n+1}-p_n+1$. Observe that these are the even numbers $p_{n+1}-t \geq p_n-1$ which is indeed our aforementioned lower bound of concern. We then look ahead in the sequence of primes $\{p_{n+1+m}\}_{m=1}^\infty$ one at a time until $q'=t+p_{n+1+m}-p_{n+1}$ is prime, as this means we can write $p_{n+1}-t=p_{n+1+m}-q'$ as a difference of two primes. This means that we are *at least* $m$ away from the next cluster prime, as $p_{n+1+m}$ is the first prime where $p_{n+1}-t$ can be written as a difference of two primes.

$M$ is the maximum number of primes to the next possible cluster prime, and changes as the algorithm progresses and $m$ increases. When we find a suitable $m$ where $p_{n+1}-t$ can be written as a difference of two primes $p_{n+1+m}-q'$, we must update $M$ to account for this "distance" to the next possible cluster prime, i.e. if $m>M$, we must update $M$ to be $m$ since $m$ is the minimum number of primes to where $p_{n+1}-t$ can be written as a difference of two primes (does this make any sense). Once we move to the next prime and begin the search again, we subtract one from $M$ as we have progressed to the next prime and are one closer to the next cluster prime. Note that as $m$ increases, so does the number of even numbers we need to search through, as we need to be able to write all even numbers up to $p_{n+1+m}-3$ as a difference of two primes. If the algorithm doesn't terminate, i.e. $M$ keeps getting larger, then that would imply there are finitely many cluster primes. However, this is a well-known hopeless problem, so for now we can assume for now that my computer is safe from blowing up.

# Implementing the Algorithm

```{r}
odd_comp <- c(9, 15, 21, 25, 27, 33, 35, 39, 45, 49, 51, 55, 57, 63, 65, 69, 75, 77, 81, 85, 87, 91, 93, 95, 99) # list of odd composites

primes<- primes(10^6) # list of primes

diff <- diff(primes) # prime differences
```

```{r}
find_next_cluster_prime <- function(n, primes, diff, odd_comp) {
  current_prime <- primes[n]
  M <- 0

  repeat {
    d <- diff[n]

    if (d > 6) {
      for (t0 in odd_comp[odd_comp <= d + 1]) {
        m <- 0
        t <- t0

        repeat {
          m <- m + 1
          t <- t + diff[n + m]

          if (isprime(t)==1) break
        }

        if (m > M) M <- m
      }
    }

    n <- n + 1
    #current_prime <- current_prime + d
    M <- M - 1

    if (M <= 0) break
  }

  return(n)
}

```

```{r}
next_n <- find_next_cluster_prime(n=24, primes, diff, odd_comp)
primes[next_n]
```

note: 97 (25th prime) is the first non-cluster prime

# Results

nothing cuz ur a fuckin idiot womp womp
